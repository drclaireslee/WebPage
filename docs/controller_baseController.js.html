<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: controller/baseController.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: controller/baseController.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import customError from "../middleware/customError.js";
import connectionHelper from "../helper/connectionHelper.js";


/** 
 * @external zod
 * @see {@link https://zod.dev/}
 */

/** 
 * @external mongoose
 * @see {@link https://mongoosejs.com/}
 */
 
/** 
 * @external express 
 * @see {@link https://expressjs.com/}
 * 
 */

/** */
class baseController {

	/**
	 * Create a baseController
	 * @param {string} modelName - The name of the model/table
	 * @param {external:zod.Object}  - The set of properties to check based on the model/table in modelName
     */
	constructor(modelName, zodSchema) {
		this.modelName = modelName;
		this.zodSchema = zodSchema;
		this.model = null;
	}

	/**
     * This method treats all schema fields as optional (partial) and strips
     * any properties in the `doc` that are not defined in the schema.
     * @param {Object} doc - The input object to validate and sanitize.
     * @returns {Object} A new object containing only the valid, known fields.
     * @throws {external:zod.ZodError} If validation fails on existing fields.
	 * @example
	 * 
	 * //Assume we have created a mongoose model named "Editor"
	 * 
	 * const editorZod = zod.object({
	 *   _id: zod.string(),
	 *	 username: zod.string(),
	 *	 passhash: zod.string(),
	 *	 role: zod.string()
	 * });
	 * 
	 * const controller = new baseController("Editor", editorZod);
	 * 
	 * const obj = {username: "Bob", passhash: "password", food: "Pizza"}
	 * 
	 * console.log(controller.validateDocument(obj));
	 * //logs {username: "Bob", passhash: "password"}
     */
	validateDocument(doc) {
		return this.zodSchema.partial().parse(doc);
	}

	/**
	 * Returns a mongoose model specified by the modelName
	 * @return {external:mongoose.Model}
	 */
	async getModel() {
		const conn = await connectionHelper();
		this.model = await conn.model(this.modelName);
		return this.model;
	}

	/**
	 * Sends a JSON response object containing an array of all documents/objects
	 * from the class's associated model/table to the client
	 * @param {external:express.req} req - an express request object
	 * @param {external:express.res} res - an express response object
	 * @return {Promise&lt;Object>} A JSON response object containing the array of documents.
	 * @example
	 * 
	 * //Assume we have created a mongoose model named "Editor"
	 * 
     * const editorZod = zod.object({
	 *   _id: zod.string(),
	 *	 username: zod.string(),
	 *	 passhash: zod.string(),
	 *	 role: zod.string()
	 * });
	 * 
	 * const controller = new baseController("Editor", editorZod);
	 * app.get("/", controller.readAll.bind(controller))
	 * 
	 * //Assume editor table has {{username: Bob, passhash:LKASJLKASDJLSAJ, role: admin}, {username: Sal, passhash:asdlkknfasdknf, role: editor}}
	 * //The JSON response will be {{username: Bob, passhash:LKASJLKASDJLSAJ, role: admin}, {username: Sal, passhash:asdlkknfasdknf, role: editor}}
	 */
	async readAll(req, res) {
		const model = await this.getModel();
	    return res.status(200).json(await model.find({}).exec());
	}

	/**
	 * Sends a JSON response object containing an array of selected documents/objects
	 * from the class's associated model/table to the client.
	 * The documents/objects that are selected occurs when all properties from req.query that
	 * also exist within the selected document/object properties match.
	 * @param {external:express.req} req - an express request object
	 * @param {external:express.res} res - an express response object
	 * @return {Promise&lt;Object>} A JSON response object containing the array of documents.
	 * @example
	 * 
	 * //Assume we have created a mongoose model named "Editor"
	 * 
     * const editorZod = zod.object({
	 *   _id: zod.string(),
	 *	 username: zod.string(),
	 *	 passhash: zod.string(),
	 *	 role: zod.string()
	 * });
	 * 
	 * const controller = new baseController("Editor", editorZod);
	 * app.get("/", controller.readFiltered.bind(controller))
	 * 
	 * //Assume editor table has {{username: Bob, passhash:LKASJLKASDJLSAJ, role: admin}, {username: Sal, passhash:asdlkknfasdknf, role: editor}}
	 * //Assume req.query has {username: Bob, food: "Pizza"}
	 * //The JSON response will be {{username: Bob, passhash:LKASJLKASDJLSAJ, role: admin}}
	 */
	async readFiltered(req, res) {
		const model = await this.getModel();
	    const doc = this.validateDocument(req.query);
	    return res.status(200).json(await model.find(doc).exec());
	}


	/**
	 * Inserts one new document/object into the class's associated model/table 
	 * based on the properties and values of req.body or the request body.
	 * The properties of the req.body that don't match the properties of the 
	 * document/object are stripped. Sends A JSON response object of
	 * the document/object that was created.
	 * @param {external:express.req} req - an express request object
	 * @param {external:express.res} res - an express response object
	 * @return {Promise&lt;Object>} A JSON response object containing the object inserted into the database.
	 * 
	 * @example
	 * 
	 * //Assume we have created a mongoose model named "Editor"
	 * 
     * const editorZod = zod.object({
	 *   _id: zod.string(),
	 *	 username: zod.string(),
	 *	 passhash: zod.string(),
	 *	 role: zod.string()
	 * });
	 * 
	 * const controller = new baseController("Editor", editorZod);
	 * app.post("/", controller.create.bind(controller))
	 * 
	 * //Assume editor table has {{username: Bob, passhash:LKASJLKASDJLSAJ, role: admin}, {username: Sal, passhash:asdlkknfasdknf, role: editor}}
	 * //Assume req.body has {username: Jerry, passhash: somepassword, role: editor, food: "Pizza"}
	 * //The JSON response will be {{username: Jerry, passhash:LKASJLKASDJLSAJ, role: editor}}
	 * //The editor table has {{username: Bob, passhash:LKASJLKASDJLSAJ, role: admin}, {username: Sal, passhash:asdlkknfasdknf, role: editor}, {username: Jerry, passhash:LKASJLKASDJLSAJ, role: editor}}
	 */
	async create(req, res) {
		const model = await this.getModel();
	    const doc = this.validateDocument(req.body);
	    const createdDoc = await model.create(doc);
	    return res.status(201).json(createdDoc);
	}

	/**
	 * Delete one document/object specified by req.params._id.
	 * Sends a JSON response object containing a message that the 
	 * document/object is deleted.
	 * @param {external:express.req} req - an express request object
	 * @param {external:express.res} res - an express response object
	 * @param {external:express.next} next - an express next object
	 * @return {Promise&lt;Object>} A JSON response object containing a message.
	 * @example
	 * 
	 * //Assume we have created a mongoose model named "Editor"
	 * 
     * const editorZod = zod.object({
	 *   _id: zod.string(),
	 *	 username: zod.string(),
	 *	 passhash: zod.string(),
	 *	 role: zod.string()
	 * });
	 * 
	 * const controller = new baseController("Editor", editorZod);
	 * app.post("/", controller.delete.bind(controller))
	 * 
	 * //Assume editor table has {{_id:1, username: Bob, passhash:LKASJLKASDJLSAJ, role: admin}}
	 * //Assume req.params_id has value 1
	 * //The JSON response will be {message: "Document deleted successfully"}
	 * //The editor table has {}
	 * 
	 */
	async delete(req, res, next) {
		const model = await this.getModel();
	    const result = await model.findById(req.params._id).deleteOne().exec();
	    if (result.deletedCount == 0) {
			next(new customError(404, "Not Found: Document does not exist"));
	    } else {
	    	return res.status(200).json({message: "Document deleted successfully"});
	    }
	}



	/**
	 * Update one document/object by setting the properties and values of the req.body or request body
	 * to the document/object specified by req.params._id. 
	 * The properties of the req.body that don't match the properties of the 
	 * document/object are stripped. Sends a JSON response object containing a
	 * message that the document/object is updated.
	 * @param {external:express.req} req - an express request object
	 * @param {external:express.res} res - an express response object
	 * @param {external:express.next} next - an express next object
	 * @returns {Promise&lt;Object>} A JSON response object containing a message.
	 * @example
	 * //Assume we have created a mongoose model named "Editor"
	 * 
     * const editorZod = zod.object({
	 *   _id: zod.string(),
	 *	 username: zod.string(),
	 *	 passhash: zod.string(),
	 *	 role: zod.string()
	 * });
	 * 
	 * const controller = new baseController("Editor", editorZod);
	 * app.post("/", controller.update.bind(controller))
	 * 
	 * //Assume editor table has {{_id:1, username: Bob, passhash:LKASJLKASDJLSAJ, role: admin}, {_id:2, username: Sal, passhash:asdfJLKASDJLSAJ, role: editor}}
	 * //Assume req.params_id has value 1
	 * //Aassume req.body has {username: Orlando, food: "Pizza"}
	 * //The JSON respond will be {message: "Document updated successfully"}
	 * //The editor table has {{_id:1, username: Orlando, passhash:LKASJLKASDJLSAJ, role: admin}, {_id:2, username: Sal, passhash:asdfJLKASDJLSAJ, role: editor}}
	 * 
	 */
	async update(req, res, next) {
		const model = await this.getModel();
		const doc = this.validateDocument(req.body);
		const result = await model.findById(req.params._id).updateOne({$set: doc}).exec();
		if (result.matchedCount == 0) {
			next(new customError(404, "Not Found: Document does not exist"));
		} else {
			return res.status(200).json({message: "Document updated successfully"});
		}
	}
}


export default baseController;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Externals</h3><ul><li><a href="external-express.html">express</a></li><li><a href="external-jsonwebtoken.html">jsonwebtoken</a></li><li><a href="external-mongoose.html">mongoose</a></li><li><a href="external-zod.html">zod</a></li></ul><h3>Classes</h3><ul><li><a href="baseController.html">baseController</a></li><li><a href="customError.html">customError</a></li><li><a href="editorController.html">editorController</a></li><li><a href="labMemberController.html">labMemberController</a></li><li><a href="publicationController.html">publicationController</a></li><li><a href="researchController.html">researchController</a></li></ul><h3>Global</h3><ul><li><a href="global.html#access">access</a></li><li><a href="global.html#accessAdmin">accessAdmin</a></li><li><a href="global.html#accessUpdateUser">accessUpdateUser</a></li><li><a href="global.html#auth">auth</a></li><li><a href="global.html#authAdmin">authAdmin</a></li><li><a href="global.html#connectionHelperReturnsaconnectiontothedatabase">connectionHelperReturns a connection to the database</a></li><li><a href="global.html#errorHandler">errorHandler</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.5</a> on Mon Dec 01 2025 21:53:47 GMT-0500 (Eastern Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
